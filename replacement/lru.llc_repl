#include "cache.h"
#include <inttypes.h>
#include <vector>
#include <bits/stdc++.h>
#define MAX_REUSE_DIST 8000

struct access {
    uint64_t full_addr;
    uint32_t type;
};

FILE *outfile;
FILE *reuse_csv_krn;
FILE *reuse_csv_usr;
vector <uint64_t> access_hist[LLC_SET];
uint64_t reuse_dist_krn[MAX_REUSE_DIST];
uint64_t reuse_dist_usr[MAX_REUSE_DIST];
unordered_map <uint64_t, uint64_t> access_map;
uint64_t curr_index[LLC_SET];

// initialize replacement state
void CACHE::llc_initialize_replacement(char *tracefile)
{
    char outfilename[1024];
    char *last_slash = strrchr(tracefile, '/')+1;
    char * first_dot = strchr(tracefile, '.');
    char file[1024];
    snprintf(file, first_dot - last_slash - 5, "%s", last_slash);
    snprintf(outfilename, 102, "/data/ndesh/UGP/cloudsuite_access/%s.access", file);
    outfile = fopen(outfilename, "wb");
    if (!outfile) {
        perror("Error: ");
        assert(0);
    }
    snprintf(outfilename, 102, "/data/ndesh/UGP/cloudsuite_access/%s_krn.csv", file);
    reuse_csv_krn = fopen(outfilename, "w");
    if (!reuse_csv_krn) {
        perror("Error: ");
        assert(0);
    }
    snprintf(outfilename, 102, "/data/ndesh/UGP/cloudsuite_access/%s_usr.csv", file);
    reuse_csv_usr = fopen(outfilename, "w");
    if (!reuse_csv_usr) {
        perror("Error: ");
        assert(0);
    }
}

// find replacement victim
uint32_t CACHE::llc_find_victim(uint32_t cpu, uint64_t instr_id, uint32_t set, const BLOCK *current_set, uint64_t ip, uint64_t full_addr, uint32_t type)
{
    // baseline LRU
    return lru_victim(cpu, instr_id, set, current_set, ip, full_addr, type); 
}

// called on every cache hit and cache fill
void CACHE::llc_update_replacement_state(uint32_t cpu, uint32_t set, uint32_t way, uint64_t full_addr, uint64_t ip, uint64_t victim_addr, uint32_t type, uint8_t hit)
{
    string TYPE_NAME;
    if (type == LOAD)
        TYPE_NAME = "LOAD";
    else if (type == RFO)
        TYPE_NAME = "RFO";
    else if (type == PREFETCH)
        TYPE_NAME = "PF";
    else if (type == WRITEBACK)
        TYPE_NAME = "WB";
    else
        assert(0);

    if (hit)
        TYPE_NAME += "_HIT";
    else
        TYPE_NAME += "_MISS";

    if ((type == WRITEBACK) && ip)
        assert(0);

    access_hist[set].push_back(full_addr/64);
    curr_index[set]++;

    uint64_t block_addr = (full_addr  >> LOG2_BLOCK_SIZE);
    if (access_map.find(block_addr) != access_map.end()) {
        access_hist[set][access_map[(block_addr)]] = (uint64_t)0;
        unsigned int curr_reuse = 0;
        for (uint64_t i = access_map[(block_addr)]; i < curr_index[set]-1; i++) {
            if (access_hist[set].at(i) != 0)
                curr_reuse += 1;
        }
        if (curr_reuse < MAX_REUSE_DIST) {
            if (full_addr > 0xff00000000000000)
                reuse_dist_krn[curr_reuse]++;
            else
                reuse_dist_usr[curr_reuse]++;
        }
    }
    access_map[(block_addr)] = curr_index[set]-1;

    // uncomment this line to see the LLC accesses
    // cout << "CPU: " << cpu << "  LLC " << setw(9) << TYPE_NAME << " set: " << setw(5) << set << " way: " << setw(2) << way;
    // cout << hex << " paddr: " << setw(12) << paddr << " ip: " << setw(8) << ip << " victim_addr: " << victim_addr << dec << endl;

    struct access curr;
    curr.full_addr = full_addr;
    curr.type = type;
    fwrite(&curr, sizeof(struct access), 1, outfile);

    // baseline LRU
    if (hit && (type == WRITEBACK)) // writeback hit does not update LRU state
        return;

    return lru_update(set, way);
}

void CACHE::llc_replacement_final_stats()
{
    for(int i = 0; i < MAX_REUSE_DIST; i++) {
        fprintf(reuse_csv_krn, "%d,%" PRIu64 "\n", i, reuse_dist_krn[i]);
        fprintf(reuse_csv_usr, "%d,%" PRIu64 "\n", i, reuse_dist_usr[i]);
    }
    fclose(outfile);
    fclose(reuse_csv_krn);
    fclose(reuse_csv_usr);

}
